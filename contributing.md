# Contributing

> This repository uses
> [`cargo-make`](https://github.com/sagiegurari/cargo-make). It takes care of
> installing all the required cargo extensions, rustup components, and git
> hooks used in this repository.

## Requirements

- [Latest Rust Stable](https://rustup.rs/)

## Setup

1. `cargo install cargo-make`
2. `cargo make setup`

### For Windows Users

Git hooks are written as shell scripts and won't be enabled on Windows.

### [`cargo-make`](https://github.com/sagiegurari/cargo-make) tasks

> See `Makefile.toml` for details

- `cargo make all` to run all checks that could make CI fail. (Build, test,
  all lints, and the book)
- `cargo make build` to build all crates
- `cargo make test` to test all crates
- `cargo make format` to format all crates
- `cargo make lint` to lint all crates using `clippy` and `rustfmt`
- `cargo make book-build` to build the documentation book

## About Conventional Commits

This repository **enforces** the usage of
[conventional commits](https://www.conventionalcommits.org/en/v1.0.0/) for
automatic changelog generation.

If your PR has any commits that do not adhere to conventional commits, it will
be automatically **rejected**.

### [Cocogitto](https://docs.cocogitto.io/)

Cocogitto (`cog`) is used to verify that commit messages adhere to conventional
commits.

It runs as a CI step to enforce compliance and as a
[`commit-msg`](./scripts/hooks/commit-msg) hook to verify it locally.

#### Forgot to enable git hooks and accidentally made some non-compliant commits?

> [Cocogitto > Docs > Edit](https://docs.cocogitto.io/guide/edit.html)

Use `cog edit` to rewrite non-compliant commits. It performs a rebase, so the
edited commits will have different hashes. You'll have to `git push --force`.

### [Koji](https://github.com/cococonscious/koji)

Koji (`koji`), used as a git hook, helps you write commit messages that
adhere to conventional commits.

If you ran `cargo make setup`, you already have Koji and the git hooks
installed.

> If you want to disable Koji, set the `NO_KOJI` environment variable to any
> value.

- If you run `git commit` without a message, Koji will prompt you to assemble
  a commit message that adheres to conventional commits!
- If you run `git commit -m 'fix: I fixed something'` with a message that is
  correctly formatted, Koji will not do anything.
- For incomplete messages, Koji will use the message as the summary.

Note that Koji, by itself, does not enforce a correctly formatted commit; it
only helps create them.

## [release-plz](https://release-plz.dev/docs)

Release PR's are automatically generated by
[release-plz](https://release-plz.dev/docs).

## Project Structure

> If you want to develop your `rx_core`/`rx_bevy` compatible operators and
> observables in your own repository, I highly recommend following the same
> conventions used in this repository! At the very least for naming!

This repository houses 2 projects, `rx_core` and `rx_bevy`.

> Once both projects have matured enough, they'll probably be split into
> two separate repositories.

Note that everything below assumes you already know what an Observable, an
Operator, a Subscriber and a Subscription is and how they work.
If not, please refer to the user documentation book where it's explained in
detail what their role is, how they work and why!

### rx_core

rx_core contains all context agnostic observable and operator implementations
and serves as the root project where all other tools/trait definitions etc are
held.

### rx_bevy

`rx_bevy` implements a context to integrate `rx_core` with Bevy. It also
contains its own observables and operators that **are** dependent on the
bevy context.

### Crate naming

Crates are named from the most significant denominator to the least significant
to make sure they appear nice and grouped when sorted.

> Example: `{rx_core}_{operator}_{filter}`. Notice the three distinct segments.

Each crate is supposed to implement one thing and what that one thing needs
to provide granular control for users of the aggregator crate. Each of these
crates are only optional dependencies of `rx_core` and `rx_bevy`.

This way users can quickly get started and explore all available Observables
and Operators, and still optimize out the unused parts later.

#### First Segment - Project/Context

The first segment represents what project the crate is part of which also
signals what context they are supporting.

- Crates that implement generic observables or operators that work any context,
  should be prefixed with `rx_core`. Indicating they are part of `rx_core`.
- Crates that depend on the Bevy context because they implement something Bevy
  specific, should be prefixed with `rx_bevy`

Crates outside of this repository may **not** use the **exact** same prefix as
crates in this repository. (Although your prefix can **start** with a prefix
here. I highly recommend them at least starting with `rx_`)

My reason is that there's still a lot of un-implemented generic operators
that should all be part of the same repository.

Examples of **good** crate names outside of this repository:

- `rx_core_foo_operator_bar` is okay if it's context agnostic! `rx_core_foo`
  is not the same as `rx_core`.
- `rx_bevy_avian_observable_collision` is also okay!
- `rx_avian_observable_collision` sounds even better!
  [Avian](https://github.com/avianphysics/avian) is a Bevy crate so
  it's clear that it is using the bevy context!
- `rx_rapier_observable_collision` is okay only if it's not the Bevy related
  implementation! As [Rapier](https://github.com/dimforge/rapier) is a
  framework agnostic project.
- `rx_bevy_rapier_observable_collision`: Clearer!

Examples of **bad** crate names outside of this repository:

- `rx_core_operator_foo`: This reads as it is a first party implementation
  and is part of this repository.
  - If you really believe that it should be named like this, but you want to
    keep it in your repository, just raise an issue to ask! If it's not
    something generic, or a name of a known `rx` operator that's just not yet
    implemented here, I'm okay with it. Same with `rx_bevy`.

#### Second Segment - Category

The category of what it (mainly) implements:

- **Observable**
- **Subscription**
- **Operator**
- **Subscriber**
- **Subject**

Most Observables implement their own Subscriptions, and most Operators
implement their own Subscribers. Since the more significant thing is the
Observable and the Operator from the users perspective, if a crate implements
both an Observable and a Subscription, its category is still **Observable**.
Similarly, if it's implementing both an Operator and a Subscriber, it's category
is still **Operator**.

Crates that only implement a Subscriber or a Subscription, intended to be shared
between other crates, can have them as their category.

#### Third Segment - Name

The last segment has the name of the thing you implement. Should be concise but
clear on what it does.

Prefer Rx and Rust conventions to name certain behaviors with words like `try`,
`with`, `all` etc.

## Creating New Crates

Once you have the name of what crate you want to implement, either create one or
just copy a similar one and rename the stuff inside.

### Creating New Observables

Observables usually have at least 3-4 files besides `lib.rs`:

- `foo_observable.rs` The Observable implementation, which is responsible for
  creating a subscription.
- `foo_subscription.rs` The Subscription implementation. (Optional if you use
  an existing one)
- `foo_observable_options.rs` Options for the Observable, usually passed down
  into the subscription. (Optional)
- `foo_observable_fn.rs` Observable creator functions, they are shorter to write
  but can't have their generics default to something.
  > `observable_fn`s may be removed, but they are already behind a feature.
  > Feedback and time shall tell if they are useful or not.
- `lib.rs` pre-categorizes each module export for easy integration with the
  aggregator crate.

  ```rs
  // Declared modules
  mod foo_observable;
  mod foo_observable_options;
  mod foo_subscription;

  // Api that is public for direct consumers of this crate, but not available
  // to the consumers of the aggregator crate as it's not directly useful.
  pub use foo_subscription::*;

  // Api that is public to the users of the aggregator crate
  pub mod observable {
      pub use super::foo_observable::*;
      pub use super::foo_observable_options::*; // Options should also be here
  }
  ```

#### Observable Integration Checklist

> Using `rx_bevy_observable_foo` as an example

Once a new bevy observable has been created in this repository, make sure it's
integrated into `rx_bevy`, into the documentation, and the coverage reports:

> For observables meant for `rx_core` the same checklist applies, but with the
> [`rx_core`](./crates/rx_core/) aggregator crate instead. In this case, don't
> forget to expose the new crate for `rx_bevy` too by adding a feature in
> [`rx_bevy/Cargo.toml`](./crates/rx_bevy/Cargo.toml) as:
>
> ```toml
> # Core Observables
> all_core_observables = [
>     "observable_foo",
> ]
> observable_foo = ["rx_core/observable_foo"]
> ```

1. Add the crate to the workspace level [Cargo.toml](./Cargo.toml) file, into
   the relevant group.

   > [!IMPORTANT]
   > All new entries within a group must be inserted in alphabetical order!
   > This is true for all steps where you need to add a new entry into a list.

   ```toml
   # Observables
   rx_bevy_observable_foo = { path = "crates/rx_bevy_observable_foo" }
   ```

   > Note that `rx_core` and `rx_bevy` crates are grouped separately!

2. Add it as an optional dependency to
   [`rx_bevy/Cargo.toml`](./crates/rx_bevy/Cargo.toml) in the observables group.

   ```toml
   # Observables
   rx_bevy_observable_foo = { version = "0.1.0", path = "../rx_bevy_observable_foo", optional = true }
   ```

3. Create a new feature for the observable.
   The name of the feature should be the crate's name, without `rx_bevy`, as
   that would be redundant.

   ```toml
   # Observables
   observable_foo = ["dep:rx_bevy_observable_foo"]
   ```

4. Add it to the `all_observables` feature group if you want this to be enabled
   by default.

   ```toml
   # Observables
   all_observables = [
     "observable_foo"
   ]
   ```

5. Enable all transitive features for the newly added observable:
   - observable_fn

     ```toml
     observable_fn = [
       "rx_bevy_observable_foo?/observable_fn"
     ]
     ```

6. Open [`rx_bevy/src/lib.rs`](./crates/rx_bevy/src/lib.rs) and re-export the
   new crate within the relevant sections:
   1. Add the observable to the `observable` module:

      ```rs
      pub mod observable {
          pub use rx_core::observable::*;

          #[cfg(feature = "observable_foo")]
          pub use rx_bevy_observable_foo::observable::*;
      }
      ```

   2. Add the observable creator function to the `observable_fn` module:

      ```rs
      #[cfg(feature = "observable_fn")]
      pub mod observable_fn {
          #[cfg(feature = "observable_foo")]
          pub use rx_bevy_observable_foo::observable_fn::*;
      }
      ```

7. Add a documentation file that just includes the readme file of the crate at
   `docs/observable_bevy/foo.md`

   ```md
   <!-- markdownlint-disable -->

   {{#include ../../crates/rx_bevy_observable_foo/readme.md}}
   ```

8. Include the new page in [`SUMMARY.md`](./docs/SUMMARY.md)

   ```md
   - [Operators (Bevy)](observable_bevy.md)
     - [foo](observable_bevy/foo.md)
   ```

9. Create a new Codecov component in [`codecov.yml`](./codecov.yml) to track
   code coverage for this crate.

   ```yml
   component_management:
     individual_components:
       - component_id: rx_bevy_observable_foo
         paths:
           - crates/rx_bevy_observable_foo/**
   ```

10. If you haven't already, update the crates `readme.md` header.

    ```md
    # [observable_foo](https://github.com/AlexAegis/rx_bevy/tree/master/crates/rx_bevy_observable_foo)

    [![crates.io](https://img.shields.io/crates/v/rx_bevy_observable_foo.svg)](https://crates.io/crates/rx_bevy_observable_foo)
    [![ci](https://github.com/AlexAegis/rx_bevy/actions/workflows/ci.yml/badge.svg)](https://github.com/AlexAegis/rx_bevy/actions/workflows/ci.yml)
    [![codecov](https://codecov.io/github/AlexAegis/rx_bevy/graph/badge.svg?token=hUtTGQaWMn&component=rx_bevy_observable_foo)](https://app.codecov.io/github/AlexAegis/rx_bevy?components%5B0%5D=rx_bevy_observable_foo)
    ```

#### Observable Contract Testing

Observables must adhere to some behavioral contracts laid out in
[Runtime Contracts](https://alexaegis.github.io/rx_bevy/contracts.html).

See [Writing Tests](https://alexaegis.github.io/rx_bevy/writing_tests.html)
to learn how to write a comprehensive integration test suite that verifies that
all contracts are met.

### Creating New Operators

Operators usually have at least 4-5 files besides `lib.rs`:

- `foo_operator.rs` The Operator implementation, which is responsible for
  creating a subscriber.
- `foo_subscriber.rs` The Subscriber implementation. (Optional if you use
  an existing one, or a combination of multiple other subscribers!)
- `foo_operator_options.rs` Options for the Operator, usually passed down
  into the Subscriber. (Optional)
- `foo_extension_pipe.rs`: An extension for Observables, to construct
  a new Pipe observable with this operator. Enables this operator to be
  chainable with Observables.
- `foo_extension_compose.rs`: An extension for other Operators, to construct a
  new CompositeOperator with this operator. Enables this operator to be
  chainable with other Operators.
  > Composite Operators are a quick and dirty way to create "new" operators
  > out of existing ones, but purpose built operators will always be
  > more lean.
- `lib.rs` pre-categorizes each module export for easy integration with the
  aggregator crate.

  ```rs
  // Declared modules
  mod map_operator;
  mod map_subscriber;

  // Api that is public for direct consumers of this crate, but not available
  // to the consumers of the aggregator crate as it's not directly useful.
  pub use map_subscriber::*;

  // Api that is public to the users of the aggregator crate
  pub mod operator {
      pub use super::map_operator::*;
  }

  // Gated apis that are public to the users of the aggregator crate if the
  // feature is enabled.
  #[cfg(feature = "compose")]
  mod map_extension_compose;

  #[cfg(feature = "compose")]
  pub mod extension_compose {
      pub use super::map_extension_compose::*;
  }

  #[cfg(feature = "pipe")]
  mod map_extension_pipe;

  #[cfg(feature = "pipe")]
  pub mod extension_pipe {
      pub use super::map_extension_pipe::*;
  }
  ```

#### Operator Integration Checklist

> Using `rx_core_operator_foo` as an example

Once a new core operator has been created in this repository, make sure it's
integrated into `rx_core`, into the documentation, and the coverage reports:

> For operators meant for `rx_bevy` the same checklist applies, but with the
> [`rx_bevy`](./crates/rx_bevy/) aggregator crate instead.

1. Add the crate to the workspace level [Cargo.toml](./Cargo.toml) file, into the
   relevant group.

   > [!IMPORTANT]
   > All new entries within a group must be inserted in alphabetical order!
   > This is true for all steps where you need to add a new entry into a list.

   ```toml
   # Operators
   rx_core_operator_foo = { path = "crates/rx_core_operator_foo" }
   ```

   > Note that `rx_core` and `rx_bevy` crates are grouped separately!

2. Add it as an optional dependency to
   [`rx_core/Cargo.toml`](./crates/rx_core/Cargo.toml) in the operators group.

   ```toml
   # Operators
   rx_core_operator_foo = { version = "0.1.0", path = "../rx_core_operator_foo", optional = true }
   ```

3. Create a new feature for the operator.
   The name of the feature should be the crate's name, without `rx_core`, as
   that would be redundant, and other aggregator crates may inherit these
   features.

   ```toml
   # Operators
   operator_foo = ["dep:rx_core_operator_foo"]
   ```

4. Add it to the `all_operators` feature group if you want this to be enabled by
   default.

   ```toml
   # Operators
   all_operators = [
     "operator_foo"
   ]
   ```

5. Enable all transitive features for the newly added operator:
   - pipe

     ```toml
     pipe = [
       "rx_core_operator_foo?/pipe"
     ]
     ```

   - compose

     ```toml
     compose = [
       "rx_core_operator_foo?/compose"
     ]
     ```

6. Open [`rx_core/src/lib.rs`](./crates/rx_core/src/lib.rs) and re-export the
   new crate within the relevant sections:
   1. Add the operator to the `operator` module:

      ```rs
      pub mod operator {
         #[cfg(feature = "operator_foo")]
         pub use rx_core_operator_foo::operator::*;
      }
      ```

   2. Add the compose extension to the `extension_compose` module:

      ```rs
      #[cfg(feature = "compose")]
      pub mod extension_compose {
          #[cfg(feature = "operator_foo")]
          pub use rx_core_operator_foo::extension_compose::*;
      }
      ```

   3. Add the pipe extension to the `extension_pipe` module:

      ```rs
      #[cfg(feature = "pipe")]
      pub mod extension_pipe {
          #[cfg(feature = "operator_foo")]
          pub use rx_core_operator_foo::extension_pipe::*;
      }
      ```

7. Add a documentation file that just includes the readme file of the crate at
   `docs/12_operators_core/foo.md`

   ```md
   <!-- markdownlint-disable -->

   {{#include ../../crates/rx_core_operator_foo/readme.md}}
   ```

8. Include the new page in [`SUMMARY.md`](./docs/SUMMARY.md)

   ```md
   - [Operators (Core)](12_operators_core.md)
     - [foo](12_operators_core/foo.md)
   ```

9. Create a new Codecov component in [`codecov.yml`](./codecov.yml) to track
   code coverage for this crate.

   ```yml
   component_management:
     individual_components:
       - component_id: rx_core_operator_foo
         paths:
           - crates/rx_core_operator_foo/**
   ```

10. Add the crate to the release-plz configuration in
    [`release-plz.toml`](./release-plz.toml)

    ```toml
    [[package]]
    name = "rx_core_operator_foo"
    git_tag_name = "core-v{{ version }}"
    version_group = "rx_core"
    ```

11. If you haven't already, update the crates `readme.md` header.

    ```md
    # [operator_foo](https://github.com/AlexAegis/rx_bevy/tree/master/crates/rx_core_operator_foo)

    [![crates.io](https://img.shields.io/crates/v/rx_core_operator_foo.svg)](https://crates.io/crates/rx_core_operator_foo)
    [![ci](https://github.com/AlexAegis/rx_bevy/actions/workflows/ci.yml/badge.svg)](https://github.com/AlexAegis/rx_bevy/actions/workflows/ci.yml)
    [![codecov](https://codecov.io/github/AlexAegis/rx_bevy/graph/badge.svg?token=hUtTGQaWMn&component=rx_core_operator_foo)](https://app.codecov.io/github/AlexAegis/rx_bevy?components%5B0%5D=rx_core_operator_foo)
    ```

#### Operator Contract Testing

Operators must adhere to some behavioral contracts laid out in
[Runtime Contracts](https://alexaegis.github.io/rx_bevy/contracts.html).

See [Writing Tests](https://alexaegis.github.io/rx_bevy/writing_tests.html)
to learn how to write a comprehensive integration test suite that verifies that
all contracts are met.

### Writing Documentation

#### Doc Sync

Some information appears in multiple places, so that it's accessible from
GitHub when the repository is viewed, from the documentation book, and through
doc comments to be viewed from the editor. Since the documentation book is
mainly just a collection of the readme files of the individual crates, that's a
given, but between that and doc comments, it must be manually synced.

The primary place for the documentation is where the user can first see it
during usage.

For Observables this is the observable's struct. And for Operators this is
the pipe extension function.

The short description must be synced with the `description` field of the crate.

### Trusted Publishing

> [!IMPORTANT]
> Each new crate has to enable this **after** the first version has been
> published!

Once the first version of a crate has been released, add the release workflow
as a trusted publisher for the newly published crate at crates.io:

[https://crates.io/crates/CRATE_NAME/settings/new-trusted-publisher](https://crates.io/crates/rx_core/settings/new-trusted-publisher)

> - Workflow filename: `release_plz.yml`
> - Environment name: `crates-io`
